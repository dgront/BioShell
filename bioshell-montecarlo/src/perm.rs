use core::fmt::Display;
use log::debug;
use std::fmt;
use rand::Rng;
use bioshell_sim::{Energy, ResizableSystem};
use crate::trait_stepwise_builder::StepwiseBuilder;
use crate::trait_stepwise_mover::StepwiseMover;

#[allow(non_snake_case)]
pub struct PERM<S: ResizableSystem, E: Energy<S>> {
    /// controls the pruning rate
    pub c_low: f64,
    /// controls the enrichment rate
    pub c_hi: f64,
    /// [update_weights()]`update_weights()` method is called every `n` full chains generated
    pub update_after_n: usize,
    /// the number of full chains built do far
    chains_cnt: i64,
    Z: Vec<f64>,                        // --- partition function for each chain length
    W_low: Vec<f64>,                    // --- lower bound for the W (pruning criteria)
    W_hi: Vec<f64>,                     // --- upper bound for the W (enrichment criteria)
    Z_div_step: f64, // --- at every k-th step, the Z[k] value is divided by Z_div_step^k to make sure it fits info f64
    step: Box<dyn StepwiseMover<S, E>>, // --- stepwise mover used to build up chains
    chains: Vec<(S, f64)>, // --- stack for enriched chains
}

impl<S: ResizableSystem, E: Energy<S>> PERM<S, E> {
    #[allow(non_snake_case)]
    pub fn new(n: usize, c_low: f64, c_hi: f64, step: Box<dyn StepwiseMover<S, E>>) -> PERM<S, E> {
        // ---------- start partition function with zeros
        let Z = vec![0.0; n];
        // ---------- start pruning weights with zeros
        let W_low = vec![0.0; n];
        // ---------- start enriching weights with something extremely large
        let mut W_hi = vec![1000000.0; n];
        // ---------- Z_div[k] =  10^k
        let Z_div_step: f64 = 10.0;
        for i in 1..W_hi.len() {
            W_hi[i] = W_hi[i - 1] * 1000000.0;
        }
        let chains = Vec::new();
        return PERM {
            c_low,
            c_hi,
            update_after_n: 1,
            chains_cnt: 0,
            Z,
            W_low,
            W_hi,
            Z_div_step,
            chains,
            step,
        };
    }

    /// Returns the capacity (maximum size) of system generated by this PERM generator
    pub fn capacity(&self) -> usize {
        self.W_low.len()
    }

    /// Returns the number of chains created so far
    pub fn count_chains(&self) -> i64 {
        self.chains_cnt
    }

    /// Updates the internal weights that control pruning and enrichment events
    pub fn update_weights(&mut self) {
        for i in 0..self.capacity() {
            self.W_low[i] = self.c_low * self.Z[i] / self.Z[0];
            self.W_hi[i] = self.c_hi * self.Z[i] / self.Z[0];
        }
    }

    /// Provides statistics for the `i`-th step of generated chains.
    ///
    /// Returns `$W_i^L$`, `$W_i^H$` and `$Z_i / Z_0$`, i.e. the two critical values for pruning
    /// and enriching events (`$W_i^L$` and `$W_i^H$`, respectively) as well as the current value
    /// of the (normalized) partition function.
    pub fn weights(&self, i: usize) -> (f64, f64, f64) {
        (self.W_low[i], self.W_hi[i], self.Z[i] / self.Z[0])
    }

    pub fn chains_left(&self) -> bool {
        !self.chains.is_empty()
    }

    /// Sets a value each `w[i]` is divided by.
    ///
    /// The [`PERM`](PERM) method accumulates the total weight for a growing system as a product of weights
    /// obtained at each step, i.e. by adding a new element to a chain. Even for a modest value of
    /// a per-element weight, their product for a long chain can exceed the capacity of the `f64` variable.
    /// Therefore, the weight for a chain of `k` elements is stored internally by [`PERM`](PERM)
    /// as:
    /// ```math
    /// w = \prod_1^{k} \frac{w_i}{c} = \frac{1}{c^k} \prod_1^{k} \frac{w_i}
    /// ```
    /// By default, `c=10`; however it's reasonable to set the `c` constant to the expected value of
    /// `$w_i$`
    pub fn set_w_scale(&mut self, w_div: f64) {
        self.Z_div_step = w_div;
    }
}

impl<S: ResizableSystem, E: Energy<S>> Display for PERM<S, E> {
    /// Creates a `String` representation of this `PERM` sampler.
    /// The output shows the current state of the internal data: i, Z, W_lo, W_hi in respective columns
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> Result<(), fmt::Error> {
        let mut out: String = String::new();
        for i in 0..self.capacity() {
            out = format!(
                "{}{:.6} {:.4} {:.2} {:.2} {:.2}\n",
                out, self.chains_cnt, i, self.Z[i], self.W_low[i], self.W_hi[i]
            );
        }
        write!(f, "{}", out)
    }
}

impl<S: ResizableSystem, E: Energy<S>> StepwiseBuilder<S, E> for PERM<S, E> {
    /// Generate a new system
    ///
    /// The generated state (e.g. new coordinates) will be stored in the given `system` reference;
    /// statistical weight of this new chain will be returned.
    ///
    /// If the current chain has been pruned, this method returns 0.0 for its weight.
    fn build(&mut self, system: &mut S, energy: &E) -> f64 {
        let current_pos: usize; // --- grow the current chain from the current_pos to the maximum length (i.e. capacity)
        let mut w_tot: f64; // --- total (cumulative) weight of the current chain
                            // ---------- take the most recent stub from the stack, if there is one there waiting
        if self.chains.len() > 0 {
            let (sys, w) = self.chains.pop().unwrap();
            for i in 0..sys.get_size() {
                system.copy_from(i, &sys);
            }
            current_pos = sys.get_size();
            system.set_size(current_pos);
            w_tot = w;
        } else {
            current_pos = 1;
            self.step.start(system, energy);
            w_tot = 1.0;
            self.Z[0] += 1.0;
            debug!("starting a new system");
        }

        for i in current_pos..self.capacity() {
            // ---------- add the next element of the system
            let w: f64 = self.step.grow_by_one(system, energy);
            w_tot *= w / self.Z_div_step; // --- adjust the weight so it fits info f64
            if w_tot < self.W_low[i] && self.chains_cnt > (self.update_after_n * 2) as i64 {
                // --- prune event
                let mut rng = rand::thread_rng();
                let if_prune = rng.gen_range(0.0..1.0);
                if if_prune < 0.5 {
                    return 0.0;
                } else {
                    w_tot *= 2.0;
                }
            }
            if w_tot > self.W_hi[i] && self.chains_cnt > (self.update_after_n * 2) as i64 {
                // --- enrich event
                w_tot *= 0.5;
                self.chains.push((system.clone(), w_tot));
                debug!(
                    "enrichment: pushing on stack a cloned system of size {}",
                    system.get_size()
                );
            }
            self.Z[i] += w_tot;
        }
        if self.chains_cnt % self.update_after_n as i64 == (self.update_after_n - 1) as i64 {
            self.update_weights();
        }
        self.chains_cnt += 1;
        return w_tot;
    }
}
